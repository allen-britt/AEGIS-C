"""
AEGIS-C Exploit Validator Service
=================================

Service for validating exploitability of detected vulnerabilities through sandboxed testing.
"""

import os
import sys
import asyncio
import aiohttp
import json
import time
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional
from fastapi import FastAPI, HTTPException, BackgroundTasks
from pydantic import BaseModel
import structlog
import docker
from docker.errors import DockerException

# Configure structured logging
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)
logger = structlog.get_logger()

app = FastAPI(title="AEGIS-C Exploit Validator Service")

# Configuration
VULN_DB_URL = os.getenv("VULN_DB_URL", "http://localhost:8019")
SANDBOX_IMAGE = os.getenv("SANDBOX_IMAGE", "python:3.9-slim")
SANDBOX_TIMEOUT = int(os.getenv("SANDBOX_TIMEOUT", "300"))  # 5 minutes timeout

# Docker client for sandboxed testing
try:
    docker_client = docker.from_env()
    logger.info("Docker client initialized for sandboxed testing")
except DockerException as e:
    logger.error(f"Failed to initialize Docker client: {e}")
    docker_client = None

class ExploitTestRequest(BaseModel):
    cve_id: str
    exploit_code: Optional[str] = None
    target_environment: Dict[str, Any] = {}
    test_parameters: Dict[str, Any] = {}

class ExploitTestResult(BaseModel):
    cve_id: str
    test_id: str
    success: bool
    impact_level: str
    details: str
    timestamp: str
    logs: List[str]

class ExploitValidator:
    """Handles sandboxed testing of exploits for vulnerabilities"""
    
    def __init__(self):
        self.docker_client = docker_client
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            headers={"User-Agent": "AEGIS-C-ExploitValidator/1.0"}
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def fetch_cve_details(self, cve_id: str) -> Dict[str, Any]:
        """Fetch CVE details from vuln_db service"""
        try:
            async with self.session.get(f"{VULN_DB_URL}/cves/search?query={cve_id}") as response:
                if response.status == 200:
                    data = await response.json()
                    if data and len(data) > 0:
                        return data[0]
                logger.error(f"Failed to fetch CVE details for {cve_id}: Status {response.status}")
                return {}
        except Exception as e:
            logger.error(f"Error fetching CVE details for {cve_id}: {e}")
            return {}
    
    def run_sandboxed_test(self, cve_id: str, exploit_code: str = None, 
                           target_environment: Dict[str, Any] = None, 
                           test_parameters: Dict[str, Any] = None) -> ExploitTestResult:
        """Run exploit test in a sandboxed environment using Docker"""
        if not self.docker_client:
            return ExploitTestResult(
                cve_id=cve_id,
                test_id="N/A",
                success=False,
                impact_level="unknown",
                details="Docker client not initialized",
                timestamp=datetime.now(timezone.utc).isoformat(),
                logs=["Error: Docker client not available"]
            )
        
        test_id = f"test-{cve_id}-{int(time.time())}"
        logs = []
        success = False
        impact_level = "low"
        details = "Test initialization"
        
        try:
            # Prepare sandbox environment
            container_config = {
                "image": SANDBOX_IMAGE,
                "command": "/bin/sh -c 'sleep 300'",  # Long-running command to keep container alive
                "network_disabled": True,  # Disable network for safety
                "mem_limit": "512m",  # Limit memory usage
                "cpu_quota": 50000,  # Limit CPU usage (50% of a core)
                "auto_remove": True
            }
            
            container = self.docker_client.containers.run(**container_config, detach=True)
            logs.append(f"Sandbox container {container.id} started for {cve_id}")
            
            # If exploit code is provided, write it to a file and execute
            if exploit_code:
                # Write exploit code to a temporary file in the container
                container.exec_run(f"sh -c 'echo \"{exploit_code}\" > /exploit.py'")
                logs.append("Exploit code uploaded to sandbox")
                
                # Run the exploit code with timeout
                exec_result = container.exec_run(
                    "python /exploit.py",
                    stdout=True,
                    stderr=True
                )
                logs.extend(exec_result.output.decode().splitlines())
                
                # Determine success based on output or specific markers
                success = any("success" in line.lower() or "exploit worked" in line.lower() for line in logs)
                impact_level = "high" if success else "medium"
                details = "Exploit execution completed"
            else:
                # Simulate exploit based on CVE details or test parameters
                logs.append("No exploit code provided, running simulated test")
                success = test_parameters.get("simulate_success", False)
                impact_level = test_parameters.get("simulate_impact", "low")
                details = "Simulated exploit test completed"
            
            # Clean up by stopping the container (auto_remove will delete it)
            container.stop()
            logs.append("Sandbox container stopped")
            
        except Exception as e:
            error_msg = f"Sandbox test failed for {cve_id}: {str(e)}"
            logger.error(error_msg)
            logs.append(error_msg)
            success = False
            impact_level = "unknown"
            details = f"Test failed: {str(e)}"
        
        return ExploitTestResult(
            cve_id=cve_id,
            test_id=test_id,
            success=success,
            impact_level=impact_level,
            details=details,
            timestamp=datetime.now(timezone.utc).isoformat(),
            logs=logs[:50]  # Limit logs to prevent overload
        )

# Global instance
validator = ExploitValidator()

# API Endpoints
@app.get("/health")
async def health():
    """Health check endpoint"""
    return {"ok": True, "service": "exploit_validator", "version": "1.0.0"}

@app.post("/test", response_model=ExploitTestResult)
async def test_exploit(request: ExploitTestRequest, background_tasks: BackgroundTasks):
    """Test exploitability of a CVE in a sandboxed environment"""
    try:
        # Fetch CVE details if available
        async with validator:
            cve_details = await validator.fetch_cve_details(request.cve_id)
            if not cve_details:
                raise HTTPException(status_code=404, detail=f"CVE {request.cve_id} not found or not accessible")
        
        # Run sandboxed test (in background if long-running)
        result = validator.run_sandboxed_test(
            request.cve_id,
            request.exploit_code,
            request.target_environment,
            request.test_parameters
        )
        
        logger.info(f"Exploit test completed for {request.cve_id}: Success={result.success}, Impact={result.impact_level}")
        return result
        
    except Exception as e:
        logger.error(f"Exploit test failed for {request.cve_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Exploit test failed: {str(e)}")

@app.get("/")
async def root():
    """Root endpoint with service info"""
    return {
        "service": "AEGIS-C Exploit Validator",
        "description": "Service for validating exploitability of vulnerabilities in a sandboxed environment",
        "endpoints": {
            "/test": "POST - Test exploitability of a CVE",
            "/health": "GET - Health check"
        },
        "version": "1.0.0"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8020)
